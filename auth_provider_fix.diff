// lib/providers/auth_provider.dart
import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:unlock/core/utils/logger.dart';
import 'package:unlock/features/missions/providers/missions_provider.dart';
import 'package:unlock/features/rewards/models/reward_model.dart';
import 'package:unlock/features/rewards/providers/rewards_provider.dart';
import 'package:unlock/models/user_model.dart';
import 'package:unlock/services/auth_service.dart';

// Provider principal
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  return AuthNotifier(ref);
});

@immutable
class AuthState {
  final UserModel? user;
  final bool isLoading;
  final bool isInitialized;
  final String? error;
  final AuthStatus status;

  const AuthState({
    this.user,
    this.isLoading = false, // Default to false, will be set true in _initialize
    this.isInitialized = false,
    this.error,
    this.status = AuthStatus.unknown,
  });

  // Getters convenientes para navega√ß√£o
  bool get isAuthenticated =>
      user != null && status == AuthStatus.authenticated;

  bool get canNavigate => isInitialized && !isLoading && error == null;

  // ‚úÖ ONBOARDING - Verifica se usu√°rio precisa completar perfil
  bool get needsOnboarding {
    AppLogger.debug('üö¶ Evaluating needsOnboarding. isAuthenticated: $isAuthenticated, user: ${user?.uid}');
    if (!isAuthenticated || user == null) {
      AppLogger.debug('üö¶ needsOnboarding returning false (not authenticated or no user)');
      return false;
    }

    // Verificar campos obrigat√≥rios do onboarding
    final hasOnboardingCompleted = user!.onboardingCompleted;
    final hasCodinome = user!.codinome?.isNotEmpty == true;
    final hasAvatarId = user!.avatarId?.isNotEmpty == true;
    final hasInterests = user!.interesses.length >= 3;
    final hasBirthDate = user!.birthDate != null;

    // Debug para verificar valores
    if (kDebugMode) {
      AppLogger.debug(
        'üîç Checking onboarding for ${user!.uid}',
        data: {
          'AUTH_STATE_STATUS': status.toString(),
          'onboardingCompleted': hasOnboardingCompleted,
          'hasCodinome': hasCodinome,
          'hasAvatarId': hasAvatarId,
          'hasInterests': hasInterests,
          'hasBirthDate': hasBirthDate,
        },
      );
    }

    // Usu√°rio precisa de onboarding se:
    // 1. N√£o marcou onboarding como completo OU
    // 2. Qualquer campo obrigat√≥rio est√° vazio
    return !hasOnboardingCompleted ||
        !hasCodinome ||
        !hasAvatarId ||
        !hasInterests ||
        !hasBirthDate;
  }

  // ‚úÖ GETTER PARA VERIFICAR SE √â MENOR DE IDADE
  bool get isMinor {
    if (user?.birthDate == null) return false;
    final age = DateTime.now().difference(user!.birthDate!).inDays ~/ 365;
    return age < 18;
  }

  // ‚úÖ GETTER PARA IDADE
  int? get age {
    if (user?.birthDate == null) return null;
    return DateTime.now().difference(user!.birthDate!).inDays ~/ 365;
  }

  // Propriedades de navega√ß√£o
  bool get shouldShowSplash {
    return !isInitialized || isLoading;
  }

  bool get shouldShowLogin {
    return canNavigate && !isAuthenticated;
  }

  bool get shouldShowOnboarding {
    return canNavigate && isAuthenticated && needsOnboarding;
  }

  bool get shouldShowHome {
    return canNavigate && isAuthenticated && !needsOnboarding;
  }

  // Propriedades legadas (compatibilidade)
  bool get shouldShowSplashScreen => shouldShowSplash;
  bool get shouldShowHomeScreen => shouldShowHome;

  AuthState copyWith({
    UserModel? user, // Allow user to be explicitly set to null
    bool? isLoading,
    bool? isInitialized,
    String? error, // Allow error to be explicitly set to null
    AuthStatus? status,
  }) {
    return AuthState(
      user: (status == AuthStatus.unauthenticated) ? null : (user ?? this.user),
      isLoading: isLoading ?? this.isLoading,
      isInitialized: isInitialized ?? this.isInitialized,
      error: (status != AuthStatus.error && status != AuthStatus.unknown && error == null) ? null : (error ?? this.error),
      status: status ?? this.status,
    );
  }

  @override
  String toString() {
    return 'AuthState('
        'user: ${user?.uid}, '
        'isLoading: $isLoading, '
        'isInitialized: $isInitialized, '
        'status: $status, '
        'error: $error, '
        'needsOnboarding: $needsOnboarding, '
        'shouldShowLogin: $shouldShowLogin, '
        'shouldShowOnboarding: $shouldShowOnboarding, '
        'shouldShowHome: $shouldShowHome'
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AuthState &&
        other.user?.uid == user?.uid &&
        other.isLoading == isLoading &&
        other.isInitialized == isInitialized &&
        other.error == error &&
        other.status == status;
  }

  @override
  int get hashCode {
    return Object.hash(user?.uid, isLoading, isInitialized, error, status);
  }
}

// Estados poss√≠veis da autentica√ß√£o
enum AuthStatus {
  unknown, // Estado inicial
  authenticated, // Usu√°rio logado
  unauthenticated, // Usu√°rio n√£o logado
  error, // Erro na autentica√ß√£o
}

// Notifier da autentica√ß√£o
class AuthNotifier extends StateNotifier<AuthState> {
  final Ref _ref;
  StreamSubscription? _authSubscription;
  bool _disposed = false;
  DateTime? _sessionStartTime;

  AuthNotifier(this._ref)
      : super(const AuthState(isLoading: true, isInitialized: false)) { // Start with isLoading: true
    _initialize();
  }

  /// Inicializa√ß√£o do provider com triggers de gamifica√ß√£o
  Future<void> _initialize() async {
    if (_disposed) return;
    try {
      _sessionStartTime = DateTime.now();
      AppLogger.auth('üîÑ Inicializando AuthProvider...');
      await _trackAnalyticsEvent('auth_provider_init_start');

      // State is already set in the constructor with isLoading: true, isInitialized: false
      // No need to set it again here unless to reset to a very specific initial state.
      // The constructor's initial state is AuthState(isLoading: true, isInitialized: false)

      _authSubscription = AuthService.authStateChanges.listen(
        _handleAuthStateChange,
        onError: _handleAuthError,
      );
      AppLogger.auth('‚úÖ AuthProvider listener configurado.');
      await _trackAnalyticsEvent(
        'auth_provider_init_success',
        data: {
          'init_duration_ms': DateTime.now()
              .difference(_sessionStartTime!)
              .inMilliseconds,
        },
      );
    } catch (error) {
      _handleError('Erro na inicializa√ß√£o do AuthProvider', error);
    }
  }

  /// Handler melhorado para mudan√ßas de autentica√ß√£o
  Future<void> _handleAuthStateChange(dynamic firebaseUser) async {
    if (_disposed) return;

    AppLogger.auth(
      'üî• _handleAuthStateChange TRIGGERED',
      data: {'hasFirebaseUser': firebaseUser != null, 'uid': firebaseUser?.uid},
    );

    const initializationTimeout = Duration(seconds: 20); // Increased timeout slightly
    try {
      AppLogger.auth(
        'üîÑ Mudan√ßa no estado de autentica√ß√£o Firebase',
        data: {
          'hasUser': firebaseUser != null,
          'uid': firebaseUser?.uid,
          'email': firebaseUser?.email,
        },
      );
      // Ensure isLoading is true at the start of processing an auth change.
      // Error is nulled out as we are starting a new auth state evaluation.
      _updateState(isLoading: true, error: null);

      await (() async {
        if (firebaseUser == null) {
          await _handleUserLogout();
        } else {
          await _handleUserLogin(firebaseUser);
        }
      }())
          .timeout(
        initializationTimeout,
        onTimeout: () {
          AppLogger.error(
            '‚ùå AuthStateChange: Timeout (${initializationTimeout.inSeconds}s) ao processar mudan√ßa de autentica√ß√£o.',
          );
          _updateState(
            isLoading: false,
            isInitialized: true, // Crucial: mark as initialized even on timeout
            error: 'Tempo limite excedido ao carregar dados de autentica√ß√£o.',
            status: AuthStatus.error, //  If there was a user, this might be unauthenticated
            user: null // On timeout, assume unauthenticated or error state without user
          );
        },
      );
    } on TimeoutException catch (_) {
      // Already handled by onTimeout, but ensure state is consistent if not set there.
      if (state.isLoading || !state.isInitialized) {
         AppLogger.error('‚ùå AuthStateChange: TimeoutException n√£o tratada no onTimeout. For√ßando estado de erro.');
        _updateState(
          isLoading: false,
          isInitialized: true,
          status: AuthStatus.error,
          error: state.error ?? 'Timeout n√£o tratado ao processar autentica√ß√£o.',
          user: null
        );
      }
    } catch (error, stackTrace) {
      AppLogger.error('‚ùå AuthStateChange: Erro ao processar mudan√ßa de autentica√ß√£o.', error: error, stackTrace: stackTrace);
      _handleError('Erro ao processar mudan√ßa de autentica√ß√£o', error);
    } finally {
      AppLogger.auth(
        'üö™ _handleAuthStateChange: Entering FINALLY block. Current state before final check: $state',
      );
      // This block ensures that isLoading is false and isInitialized is true
      // after every auth state change processing, regardless of success or failure,
      // unless a timeout/error handler already did this.
      if (state.isLoading || !state.isInitialized) {
        final finalStatus = (state.status == AuthStatus.unknown && state.error == null)
            ? (state.user != null ? AuthStatus.authenticated : AuthStatus.unauthenticated) // More accurate guess
            : state.status;

        AppLogger.auth(
          'üö™ _handleAuthStateChange FINALLY: Estado precisou de atualiza√ß√£o (isLoading: ${state.isLoading}, !isInitialized: ${!state.isInitialized}). FinalStatus: $finalStatus',
        );
        _updateState(
          isLoading: false,
          isInitialized: true,
          status: finalStatus,
          // user: finalStatus == AuthStatus.unauthenticated ? null : state.user, // This was potentially problematic
          // Let _updateState handle user based on status if not explicitly passed
        );
        AppLogger.auth(
          'üö™ _handleAuthStateChange FINALLY: Estado atualizado. Novo estado: $state',
        );
      } else {
         AppLogger.auth(
            'üö™ _handleAuthStateChange FINALLY: Nenhuma atualiza√ß√£o de estado necess√°ria (isLoading: ${state.isLoading}, isInitialized: ${state.isInitialized}). Estado atual: $state');
      }
    }
  }


  /// Lidar com login do usu√°rio (com triggers)
  Future<void> _handleUserLogin(dynamic firebaseUser) async {
    if (_disposed) return;
    AppLogger.auth('üîÑ _handleUserLogin: Iniciando para Firebase UID: ${firebaseUser.uid}. Estado atual: $state');
    // isLoading should already be true from _handleAuthStateChange
    try {
      final loadStartTime = DateTime.now();
      final userModel = await AuthService.getOrCreateUserInFirestore(firebaseUser);

      AppLogger.auth(
        'üí° _handleUserLogin: UserModel carregado/criado.',
        data: {
          'userModelIsNull': userModel == null,
          'uid': userModel?.uid,
          'onboardingCompleted': userModel?.onboardingCompleted,
          'codinome': userModel?.codinome,
        },
      );

      if (userModel != null) {
        final loadDuration = DateTime.now().difference(loadStartTime);
        await _trackAnalyticsEvent(
          'user_data_loaded',
          data: {
            'load_duration_ms': loadDuration.inMilliseconds,
            'user_level': userModel.level,
            'onboarding_completed': userModel.onboardingCompleted,
          },
        );
        _updateState(
          user: userModel,
          isLoading: false, // Crucial: mark loading as false
          isInitialized: true, // Crucial: mark as initialized
          status: AuthStatus.authenticated,
          error: null, // Clear any previous error
        );
        AppLogger.auth('‚úÖ _handleUserLogin: Usu√°rio autenticado e dados carregados. Novo estado: $state');
        await _triggerGamificationSystems(userModel);
      } else {
        AppLogger.error('‚ùå _handleUserLogin: Falha ao carregar/criar UserModel para UID: ${firebaseUser.uid}. For√ßando logout.');
        _updateState(
          isLoading: false, // Crucial: mark loading as false
          isInitialized: true, // Crucial: mark as initialized
          status: AuthStatus.error,
          error: 'Falha ao carregar dados do usu√°rio ap√≥s login.',
          user: null,
        );
        await AuthService.signOut().catchError(
          (e, s) => AppLogger.error("Erro no signOut for√ßado ap√≥s falha de carregamento de UserModel", error: e, stackTrace: s),
        );
      }
    } catch (error, stackTrace) {
      AppLogger.error('‚ùå _handleUserLogin: Erro ao carregar dados do usu√°rio.', error: error, stackTrace: stackTrace);
      _handleError('Erro ao carregar dados do usu√°rio', error);
      // Attempt to sign out if user data loading fails critically
      try {
        await AuthService.signOut();
      } catch (signOutError, signOutStackTrace) {
        AppLogger.error('‚ùå _handleUserLogin: Erro adicional no signOut ap√≥s falha de carregamento.', error: signOutError, stackTrace: signOutStackTrace);
      }
    }
  }

  /// Trigger para sistemas de gamifica√ß√£o ap√≥s login
  Future<void> _triggerGamificationSystems(UserModel user) async {
    if (_disposed) return;
    try {
      AppLogger.auth('üéÆ Disparando triggers de gamifica√ß√£o para ${user.uid}');
      final missionsNotifier = _ref.read(missionsProvider.notifier);
      if (missionsNotifier.state.isLoading) {
        AppLogger.debug('MissionsNotifier ainda carregando, aguardando...');
        await for (var _ in missionsNotifier.stream) {
          if (!missionsNotifier.state.isLoading) break;
        }
        AppLogger.debug('MissionsNotifier finalizou o carregamento.');
      }
      await _triggerMissionsSystem(user);
      await _triggerRewardsSystem(user);
      await _triggerDailyLogin(user);
      AppLogger.auth('‚úÖ Todos os triggers de gamifica√ß√£o executados para ${user.uid}');
    } catch (e, s) {
      AppLogger.error('‚ùå Erro ao disparar triggers de gamifica√ß√£o', error: e, stackTrace: s);
    }
  }

  /// Trigger espec√≠fico para sistema de miss√µes
  Future<void> _triggerMissionsSystem(UserModel user) async {
    try {
      AppLogger.debug('üéØ Trigger: Sistema de Miss√µes para ${user.uid}');
      await _trackAnalyticsEvent(
        'missions_system_triggered',
        data: {
          'user_id': user.uid,
          'user_level': user.level,
          'onboarding_completed': user.onboardingCompleted,
        },
      );
      AppLogger.debug('‚úÖ Trigger de miss√µes executado para ${user.uid}');
    } catch (e, s) {
      AppLogger.error('‚ö†Ô∏è Trigger de miss√µes falhou (n√£o cr√≠tico)', error: e, stackTrace: s);
    }
  }

  /// Trigger espec√≠fico para sistema de recompensas
  Future<void> _triggerRewardsSystem(UserModel user) async {
    try {
      AppLogger.debug('üéÅ Trigger: Sistema de Recompensas para ${user.uid}');
      await _trackAnalyticsEvent(
        'rewards_system_triggered',
        data: {'user_id': user.uid},
      );
      AppLogger.debug('‚úÖ Trigger de recompensas executado para ${user.uid}');
    } catch (e, s) {
      AppLogger.error(
        '‚ö†Ô∏è Trigger de recompensas falhou (n√£o cr√≠tico)',
        error: e,
        stackTrace: s
      );
    }
  }

  /// Trigger para login di√°rio
  Future<void> _triggerDailyLogin(UserModel user) async {
    try {
      AppLogger.debug('üìÖ Trigger: Login Di√°rio para ${user.uid}');
      final now = DateTime.now();
      final today = DateTime(now.year, now.month, now.day);
      final DateTime? lastLoginDate = user.lastLoginDate;
      int currentStreak = user.loginStreak ?? 0;
      bool isFirstLoginToday = true;

      if (lastLoginDate != null) {
        final DateTime lastLoginDay = DateTime(
          lastLoginDate.year,
          lastLoginDate.month,
          lastLoginDate.day,
        );
        if (lastLoginDay.isAtSameMomentAs(today)) {
          isFirstLoginToday = false;
          AppLogger.debug('Login di√°rio j√° processado hoje para ${user.uid}.');
        } else {
          final DateTime yesterday = today.subtract(const Duration(days: 1));
          if (lastLoginDay.isAtSameMomentAs(yesterday)) {
            currentStreak++;
          } else {
            currentStreak = 1; // Quebrou a sequ√™ncia
          }
        }
      } else {
        currentStreak = 1; // Primeiro login
      }

      if (isFirstLoginToday) {
        AppLogger.debug(
          'Processando primeiro login do dia para ${user.uid}. Streak: $currentStreak',
        );
        final bonusCoins = _ref
            .read(rewardsProvider.notifier)
            .calculateDailyLoginBonus(currentStreak);
        if (bonusCoins > 0) {
          _ref
              .read(authProvider.notifier)
              .addRewardsToCurrentUser(0, bonusCoins, 0);
          await _ref
              .read(rewardsProvider.notifier)
              .recordDirectlyClaimedCoinReward(
                userId: user.uid,
                amount: bonusCoins,
                source: RewardSource.dailyLogin,
                description: 'B√¥nus de login di√°rio ($currentStreak dias)',
                metadata: {'streakDays': currentStreak},
              );
        }
        await FirebaseFirestore.instance
            .collection('users')
            .doc(user.uid)
            .update({
          'lastLoginDate': Timestamp.fromDate(now),
          'loginStreak': currentStreak,
          'lastLogin': FieldValue.serverTimestamp(), // Use server timestamp for lastLogin
        });
        _ref.read(missionsProvider.notifier).reportMissionEvent('LOGIN_DAILY');
        await _trackAnalyticsEvent(
          'daily_login_bonus_granted',
          data: {
            'user_id': user.uid,
            'streak': currentStreak,
            'bonus_coins': bonusCoins,
          },
        );
      }
      AppLogger.debug('‚úÖ Trigger de login di√°rio conclu√≠do para ${user.uid}.');
    } catch (e, s) {
      AppLogger.error(
        '‚ö†Ô∏è Trigger de login di√°rio falhou (n√£o cr√≠tico)',
        error: e,
        stackTrace: s
      );
    }
  }

  /// Lidar com logout do usu√°rio
  Future<void> _handleUserLogout() async {
    if (_disposed) return;
    AppLogger.auth(
      'üîÑ _handleUserLogout: Iniciando. Estado atual: $state',
    );
    try {
      AppLogger.auth('üßπ Limpando estado do usu√°rio (logout)');
      await _trackAnalyticsEvent('user_logged_out');
      _updateState(
        user: null, // Explicitly set user to null
        isLoading: false,
        isInitialized: true,
        status: AuthStatus.unauthenticated,
        error: null, // Clear any previous error
      );
      AppLogger.auth(
        '‚úÖ _handleUserLogout: Estado atualizado para n√£o autenticado. Novo estado: $state',
      );
    } catch (e, s) {
      AppLogger.error('‚ùå Erro durante o processamento do logout local', error: e, stackTrace: s);
      _updateState( // Ensure a clean unauthenticated state even if local processing fails
        user: null,
        isLoading: false,
        isInitialized: true,
        status: AuthStatus.unauthenticated,
        error: 'Erro ao processar logout local, mas Firebase des
